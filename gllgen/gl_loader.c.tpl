// this file has been automatically generated by gllgen.py
#include "gl_loader.h"
#include <stdio.h>

// to activate logging, LOG, LOG_WARNING, LOG_ERROR, and LOG_DEBUG
// macros should be defined using any logging interface

#ifndef LOG
	#define LOG(fmt, ...)
#endif

#ifndef LOG_WARNING
	#define LOG_WARNING(fmt, ...)
#endif

#ifndef LOG_ERROR
    #define LOG_ERROR(fmt, ...)
#endif

#ifndef LOG_DEBUG
	#define LOG_DEBUG(fmt, ...)
#endif

#define GL_MAX_EXTENSION_COUNT 1024
#define GL_MAX_EXTENSION_STRING_LEN (GL_MAX_EXTENSION_COUNT * 32)

static GLboolean		l_loaded = GL_FALSE;
static GLuint			l_extensionCount;
static char				l_extensionString[GL_MAX_EXTENSION_STRING_LEN];
static const char		*l_pExtensions[GL_MAX_EXTENSION_COUNT];

// Function Pointers
{% for version, proc_list in GL_CORE -%}
// OpenGL {{version}}
{% for proc_type, proc_name in proc_list -%}
{{proc_type}} {{proc_name}} = NULL;	
{% endfor %}
{% endfor %}


// Library Loading
typedef (*PFNGLVOIDFUNCTION)(void);
#if defined(_WIN32)
static GLboolean GL_OpenLib() { return GL_TRUE; }
static void GL_CloseLib() {}
static PFNGLVOIDFUNCTION GL_GetProcAddr(const char *procName)
{ return (PFNGLVOIDFUNCTION)wglGetProcAddress((LPCSTR)procName); }
#endif

GLboolean GL_LoadAPI(void)
{
	const char *version, *ext;
	char *ptr, *start;
	GLuint major, minor, res, i;
	PFNGLGETSTRINGIPROC glGetStringiLocal;

	if(l_loaded == GL_TRUE){
		LOG_WARNING("GL_LoadAPI: API is already loaded!");
		return GL_TRUE;
	}

	version = glGetString(GL_VERSION);
	if(version == NULL){
		LOG_ERROR("GL_LoadAPI: failed to fetch GL version string! Maybe the context was not properly created.");
		return GL_FALSE;
	}

	if(sscanf(version, "%d.%d", &major, &minor) != 2){
		LOG_ERROR("GL_LoadAPI: invalid OpenGL version string! Maybe the context was not properly created.");
		return GL_FALSE;
	}

	// retrieving the implementation extensions
	// differs from OpenGL vesions prior to 3.0
	if(major < 3){
		// Here we get the OpenGL implementation static string with
		// glGetString and copy it to a local buffer(l_extensionString).
		// After that we replace every space character (0x20) for a null
		// character (0x00) and reference the start of each extension in
		// a pointer array (l_pExtensions).

		l_extensionCount = 0;
		ext = glGetString(GL_EXTENSIONS);
		memcpy(l_extensionString, ext, strlen(ext) + 1);
		start = l_extensionString;
		ptr = start;
		while(*ptr != 0){
			if(*ptr == 0x20){
				*ptr = 0x00;
				l_pExtensions[l_extensionCount] = start;
				l_extensionCount++;
				start = ptr + 1;
			}
			ptr++;
		}
	}
	else{
		glGetStringiLocal = (PFNGLGETSTRINGIPROC)GL_GetProcAddr("glGetStringi");
		if(glGetStringiLocal == NULL){
			LOG_ERROR("GL_LoadAPI: failed to retrieve 'glGetStringi' proc! Unable to load API.");
			return GL_FALSE;
		}

		glGetIntegerv(GL_NUM_EXTENSIONS, &l_extensionCount);
		for(i = 0; i < l_extensionCount; i++)
			l_pExtensions[i] = glGetStringiLocal(GL_EXTENSIONS, i);
	}

	// Load GL Core
	//=================================================================
	#define GL_GET_PROC_ADDR(proc_type, proc_name)									\
		proc_name = (proc_type) GL_GetProcAddr(#proc_name);							\
		if(proc_name == NULL){														\
			LOG_ERROR("GL_LoadAPI: failed to load core proc '%s'!", #proc_name);	\
			res = GL_FALSE;															\
		}

	res = GL_TRUE;
	{% for version, proc_list in GL_CORE -%}
	if(major < {{version.major()}} || major == {{version.major()}} && minor <= {{version.minor()}}){
		res = GL_TRUE;
		{% for proc_type, proc_name in proc_list -%}
		GL_GET_PROC_ADDR({{proc_type}}, {{proc_name}});
		{% endfor %}

		if(res == GL_FALSE){
			LOG_ERROR("GL_LoadAPI: failed to load OpenGL Core {{version}}");
			return GL_FALSE;
		}
	}
	{% endfor %}
	#undef GL_GET_PROC_ADDR
	//=================================================================


	return GL_TRUE;
}

void GL_UnloadAPI()
{
	GL_CloseLib();
	l_loaded = GL_FALSE;
}

